// Camera & Viewport
cam_view_update_src = `
  // TODO: Update the following values using image, camera, and viewport:
  //    - camera.basis (Basis): The three basis vectors for the camera and viewport space
  // Building the view frame
  let upNorm : vec3f = normalize(camera.up);
  let gazeNorm : vec3f = normalize(camera.gaze);
  var u : vec3f = cross(upNorm, gazeNorm);
  let upNorm2 : vec3f = (cross(u, gazeNorm));

// Sets camera basis
  camera.basis.xhat = u;
  camera.basis.yhat = upNorm2;

//    - viewport.origin (vec3f): The viewport's origin
  let viewCenter : vec3f = camera.origin + (camera.f*camera.gaze);
  //viewport.origin = viewCenter - (0.5*viewport.width*u) - (0.5*viewport.height*upNorm2) + 0.5*(u + upNorm2); // ASK WHY THIS DOESNT WORK
  viewport.origin = viewCenter - (0.5*viewport.width*u) - (0.5*viewport.height*upNorm2);

  //    - image.pixel_width (f32): The width of an individual pixel
  image.pixel_width = viewport.width / f32(image.width);

  //    - image.pixel_height (f32): The height of an individual pixel
  image.pixel_height = viewport.height / f32(image.height);
  camera.basis.zhat = -gazeNorm;

`

// Ray Generation
generate_ray_src = `
// TODO: If you want to calculate any constants to use elsewhere, do so here.

// The function to generate the rays. Returns both the ray origin on the viewport
// and the ray direction.
//
// ray has two elements:
//   - ray.origin (vec3f): The ray's origin on the viewport (at the pixel center)
//   - ray.direction (vec3f): The ray's direction. Should be normalized.
fn generate_ray(i : u32, j : u32) -> ray_struct
{
  var ray : ray_struct;

  // TODO: Calculate and set the ray.origin and ray.direction
  // The default (which you will replace) is a ray from the origin with no
  // orientation

  ray.origin = viewport.origin + (f32(i)*image.pixel_width*camera.basis.xhat) + (f32(j)*image.pixel_height*camera.basis.yhat);

  ray.direction = normalize(ray.origin - camera.origin);
  return ray;
}
`

// Sphere Implementation
sphere_src = `
fn intersect_sphere(ray : ray_struct, sphere : sphere_struct) -> hit_info_struct
{
  var hit_info = populate_hit(sphere.object_id);

  // TODO: Intersect ray with the sphere. If there is an intersection, update the
  // Variables for calculation
  var a : f32 = dot(ray.direction, ray.direction);
  var b : f32 = 2 * dot(ray.origin - sphere.center, ray.direction);
  var c : f32 = dot(ray.origin - sphere.center, ray.origin - sphere.center) - (sphere.radius * sphere.radius);

  // Intersection variable
  var discrim : f32 = (b*b) - 4*(a*c);

  // Intersection Distance Variables
  var tPos : f32 = (-b + sqrt(discrim)) / (2*a);
  var tNeg : f32 = (-b - sqrt(discrim)) / (2*a);
  var t : f32;

  // Intersection Distance
  if (tPos < tNeg && tPos >= 0)
  {
    t = tPos;
  }
  else if (tNeg < tPos && tNeg >= 0)
  {
    t = tNeg;
  } 

  // Intersection Count
  // No Intersection
  if (discrim < 0)
  {
    hit_info.valid = false;
  }
  // 1 Intersection
  else if(discrim == 0)
  {
    hit_info.distance = t;
    hit_info.valid = true;
  }
  // 2 Intersection
  else
  {
    hit_info.distance = t;
    hit_info.valid = true;
  } 

  return hit_info;
}
`

// Plane Implementation
plane_src = `
fn intersect_plane(ray : ray_struct, plane : plane_struct) -> hit_info_struct
{
  var hit_info = populate_hit(plane.object_id);

  // TODO: Intersect ray with the plane. If there is an intersection, update the
  // hit_info.

  // Intersection
  var t : f32 = -dot(ray.origin - plane.point, plane.normal) / dot(ray.direction, plane.normal);

  // Intersection Miss
  if (approx_equal(dot(ray.direction, plane.normal), 0.0) && dot(plane.point - ray.origin, plane.normal) != 0)
  {
    hit_info.valid = false;
  }
  // Intersection Hit
  else
  {
    hit_info.valid = true;
    hit_info.distance = t;
  }

  return hit_info;
}
`

// Triangle Implementation
triangle_src = `
fn intersect_triangle(ray : ray_struct, triangle : triangle_struct) -> hit_info_struct
{
  var hit_info = populate_hit(triangle.object_id);

  // TODO: Intersect ray with the triangle. If there is an intersection, update the
  // hit_info.
  // From Moller & Trombore '97

  // Edge Vectors
  var e10 : vec3f = triangle.p1 - triangle.p0;
  var e20 : vec3f = triangle.p2 - triangle.p0;

  // Variables
  var r00 : vec3f = ray.origin - triangle.p0;
  var detM : f32 = dot(e10, cross(ray.direction, e20));
  var t : f32 = dot(e20, cross(r00, e10)) / detM;

  // Barycentric Coordinates
  var alpha : f32 = dot(r00, cross(ray.direction, e20)) / detM;
  var beta : f32 = dot(ray.direction, cross(r00, e10)) / detM;
  //var rt : vec3f = (1 - alpha - beta)*triangle.p0 + (beta*triangle.p1) + (alpha*triangle.p2);

  // Intersection Miss (detM = ray & triangle plane parallel, alpha & beta = outside triangle, t = behind us)
  if (detM == 0 || alpha < 0 || alpha > 1 || beta < 0 || beta > 1 || hit_info.distance < 0 || alpha + beta <= 1)
  {
      hit_info.valid = false;
  }
  // Intersection Hit
  else
  {
    hit_info.valid = true;
    hit_info.distance = t;
  } 

  return hit_info;
}
`

// Color 
set_color_src = `
  // TODO: Set the color (a vec3f). The shader variables ray & hit_info holds the current
  // ray's datafo.
  // The default color (which you will replace if an object was hit) is white
  // Detect Valid Hit
  if(hit_info.valid == true)
  {
    // Loop for number of objects in scene
    for(var i : i32 = 0; i <= i32(num_objects); i++)
    {
      // Change color for each object
      if (i32(hit_info.object_id) == i)
      {
        color.x = f32(i) / f32(num_objects);
        color.y = f32(i) / (f32(num_objects) *2);
        color.z = f32(i) / f32(num_objects);
      }
    }
  }
  // Return White if No Valid Hits
  else
  {
    color = vec3f(1, 1, 1);
  }
`
